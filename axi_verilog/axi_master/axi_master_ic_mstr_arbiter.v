//------------------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- RobustVerilog version 1.5g (limited free version) Jul 5 2011
//-- Invoked Wed Mar 28 12:55:30 2012
//-- Source file: ic_arbiter.v
//-- Parent file: ic_addr.v
//-- Project directory: C:/Users/MARIOS/Desktop/VLSI/RobustVerilog_free1.5_win/RobustVerilog_free1.5_win/examples/axi_master/trunk/run/
//-- Target directory: out/
//-- Command flags: ..\..\..\..\robust.exe ../robust_axi_master.pro -gui 
//-- www.provartec.com/edatools ... info@provartec.com
//------------------------------------------------------------------





  
module axi_master_ic_mstr_arbiter(clk,reset,M_last,M_req,M_grant,M0_slave,M1_slave,M2_slave,S0_master);

   input                   clk;
   input                   reset;

   input [3-1:0]           M_last;
   input [3-1:0]           M_req;
   input [3-1:0]           M_grant;
   
   input [1-1:0]           M0_slave;
   input [1-1:0]           M1_slave;
   input [1-1:0]           M2_slave;
   
   output [3-1:0]           S0_master;


   
   reg [3:0]               S0_master_prio_reg;
   wire [3-1:0]               S0_master_prio;
   reg [3-1:0]               S0_master_d;
   
   wire [3-1:0]               M_S0;
   wire [3-1:0]               M_S0_valid;
   wire [3-1:0]               M_S0_prio;
   reg [3-1:0]               M_S0_burst;


   
   
   parameter                   MASTER_NONE = 3'b000;
   parameter                   MASTER0    = 3'b001;
   parameter                   MASTER1    = 3'b010;
   parameter                   MASTER2    = 3'b100;
   
   
   

   always @(posedge clk or posedge reset)
     if (reset)
       begin
      S0_master_prio_reg[3:1] <= #1 {3{1'b0}};
      S0_master_prio_reg[0]          <= #1 1'b1;
       end
     else if (|(M_req & M_grant & M_last))
       begin      
      S0_master_prio_reg[3:1] <= #1 S0_master_prio_reg[3-1:0];
      S0_master_prio_reg[0]          <= #1 S0_master_prio_reg[3-1];
       end

   assign S0_master_prio = S0_master_prio_reg[3-1:0];
   
   assign M_S0_prio      = M_S0_valid & S0_master_prio;
   


   always @(posedge clk or posedge reset)
     if (reset)
       begin
      S0_master_d <= #1 {3{1'b0}};
       end
     else
       begin
      S0_master_d <= #1 S0_master;
       end

     always @(posedge clk or posedge reset)                        
       if (reset)                                                  
     begin                                                     
        M_S0_burst[0] <= #1 1'b0;                        
     end                                                       
       else if (M_req[0])                         
     begin                                                     
        M_S0_burst[0] <= #1 S0_master[0] & (M_grant[0] ? (~M_last[0]) : 1'b1); 
     end
   
     always @(posedge clk or posedge reset)                        
       if (reset)                                                  
     begin                                                     
        M_S0_burst[1] <= #1 1'b0;                        
     end                                                       
       else if (M_req[1])                         
     begin                                                     
        M_S0_burst[1] <= #1 S0_master[1] & (M_grant[1] ? (~M_last[1]) : 1'b1); 
     end
   
     always @(posedge clk or posedge reset)                        
       if (reset)                                                  
     begin                                                     
        M_S0_burst[2] <= #1 1'b0;                        
     end                                                       
       else if (M_req[2])                         
     begin                                                     
        M_S0_burst[2] <= #1 S0_master[2] & (M_grant[2] ? (~M_last[2]) : 1'b1); 
     end
   
      
     assign                              M_S0 = {M2_slave == 'd0  , M1_slave == 'd0  , M0_slave == 'd0 };
   
   assign                  M_S0_valid = M_S0 & M_req;
   
   
     assign                    S0_master = 
                               M_S0_burst[0] ? S0_master_d : 
                               M_S0_burst[1] ? S0_master_d : 
                               M_S0_burst[2] ? S0_master_d : 
                                           M_S0_prio[0]  ? MASTER0 :  
                                           M_S0_prio[1]  ? MASTER1 :  
                                           M_S0_prio[2]  ? MASTER2 :  
                            M_S0_valid[0] ? MASTER0 :      
                            M_S0_valid[1] ? MASTER1 :      
                            M_S0_valid[2] ? MASTER2 :      
                            MASTER_NONE;
   
      
     endmodule




