//------------------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- RobustVerilog version 1.5g (limited free version) Jul 5 2011
//-- Invoked Wed Mar 28 12:55:30 2012
//-- Source file: axi_master_stall.v
//-- Parent file: axi_master_single.v
//-- Project directory: C:/Users/MARIOS/Desktop/VLSI/RobustVerilog_free1.5_win/RobustVerilog_free1.5_win/examples/axi_master/trunk/run/
//-- Target directory: out/
//-- Command flags: ..\..\..\..\robust.exe ../robust_axi_master.pro -gui 
//-- www.provartec.com/edatools ... info@provartec.com
//------------------------------------------------------------------





  
module axi_master_stall(clk,reset,rd_hold,wr_hold,ARVALID_pre,RREADY_pre,AWVALID_pre,WVALID_pre,BREADY_pre,ARREADY,AWREADY,WREADY,ARVALID,RREADY,AWVALID,WVALID,BREADY);
   
`include "prgen_rand.v"
   
   input               clk;
   input               reset;

   input               rd_hold;
   input               wr_hold;
   
   input               ARVALID_pre;
   input               RREADY_pre;
   input               AWVALID_pre;
   input               WVALID_pre;
   input               BREADY_pre;

   input               ARREADY;
   input               AWREADY;
   input               WREADY;
   
   output               ARVALID;
   output               RREADY;
   output               AWVALID;
   output               WVALID;
   output               BREADY;


   reg                        stall_enable = 1;
   
   integer                    burst_chance    = 1;
   integer               burst_len       = 10;
   integer               burst_val       = 90;
   
   integer               ar_stall_chance = 10;
   integer               r_stall_chance  = 10;
   integer               aw_stall_chance = 10;
   integer               w_stall_chance  = 10;
   integer               b_stall_chance  = 10;

   
   integer               burst_type;
   reg                   burst_stall;
   integer               ar_stall_chance_valid;
   integer               r_stall_chance_valid;
   integer               aw_stall_chance_valid;
   integer               w_stall_chance_valid;
   integer               b_stall_chance_valid;
   
   
   reg                   ARSTALL_pre = 0;
   reg                   RSTALL_pre  = 0;
   reg                   AWSTALL_pre = 0;
   reg                   WSTALL_pre  = 0;
   reg                   BSTALL_pre  = 0;
   reg                   ARSTALL;
   reg                   RSTALL;
   reg                   AWSTALL;
   reg                   WSTALL;
   reg                   BSTALL;

   

   assign               ARVALID = ARVALID_pre & (~ARSTALL) & (~rd_hold);
   assign               RREADY  = RREADY_pre  & (~RSTALL);
   assign               AWVALID = AWVALID_pre & (~AWSTALL) & (~wr_hold);
   assign               WVALID  = WVALID_pre  & (~WSTALL);
   assign               BREADY  = BREADY_pre  & (~BSTALL);


   task set_stall;
      reg stall;
      begin
         ar_stall_chance_valid = ar_stall_chance;
         r_stall_chance_valid  = r_stall_chance;
         aw_stall_chance_valid = aw_stall_chance;
         w_stall_chance_valid  = w_stall_chance;
         b_stall_chance_valid  = b_stall_chance;
      end
   endtask

   initial
     begin
    #1;
    set_stall;

    if (burst_chance > 0)
      forever
        begin
           burst_stall = rand_chance(burst_chance);
           
           if (burst_stall)
         begin
            #1;
            burst_type = rand(1, 5);
            
            case (burst_type)
              1 : ar_stall_chance_valid = burst_val;
              2 : r_stall_chance_valid  = burst_val;
              3 : aw_stall_chance_valid = burst_val;
              4 : w_stall_chance_valid  = burst_val;
              5 : b_stall_chance_valid  = burst_val;
            endcase
            
            repeat (burst_len) @(posedge clk);
            set_stall;
         end
           else
         begin
            @(posedge clk);
         end
        end
     end
   
   always @(posedge clk)
     begin
    #1;
    ARSTALL_pre = rand_chance(ar_stall_chance_valid);
        RSTALL_pre  = rand_chance(r_stall_chance_valid);
        AWSTALL_pre = rand_chance(aw_stall_chance_valid);
        WSTALL_pre  = rand_chance(w_stall_chance_valid);
        BSTALL_pre  = rand_chance(b_stall_chance_valid);
     end
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
          ARSTALL <= #1 1'b0;
          RSTALL  <= #1 1'b0;
          AWSTALL <= #1 1'b0;
          WSTALL  <= #1 1'b0;
          BSTALL  <= #1 1'b0;
       end
     else if (stall_enable)
       begin
          ARSTALL <= #1 ARSTALL_pre & ARREADY; //keep VALID signal stable while ~READY
          RSTALL  <= #1 RSTALL_pre;
          AWSTALL <= #1 AWSTALL_pre & AWREADY; //keep VALID signal stable while ~READY
          WSTALL  <= #1 WSTALL_pre & WREADY; //keep VALID signal stable while ~READY
          BSTALL  <= #1 BSTALL_pre;
       end
     else
       begin
          ARSTALL <= #1 1'b0;
          RSTALL  <= #1 1'b0;
          AWSTALL <= #1 1'b0;
          WSTALL  <= #1 1'b0;
          BSTALL  <= #1 1'b0;
       end
   
endmodule
   









