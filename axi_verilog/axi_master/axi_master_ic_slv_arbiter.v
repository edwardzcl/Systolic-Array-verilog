//------------------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- RobustVerilog version 1.5g (limited free version) Jul 5 2011
//-- Invoked Wed Mar 28 12:55:32 2012
//-- Source file: ic_arbiter.v
//-- Parent file: ic_resp.v
//-- Project directory: C:/Users/MARIOS/Desktop/VLSI/RobustVerilog_free1.5_win/RobustVerilog_free1.5_win/examples/axi_master/trunk/run/
//-- Target directory: out/
//-- Command flags: ..\..\..\..\robust.exe ../robust_axi_master.pro -gui 
//-- www.provartec.com/edatools ... info@provartec.com
//------------------------------------------------------------------





  
module axi_master_ic_slv_arbiter(clk,reset,M_last,M_req,M_grant,M0_slave,S0_master,S1_master,S2_master);

   input                   clk;
   input                   reset;

   input [1-1:0]           M_last;
   input [1-1:0]           M_req;
   input [1-1:0]           M_grant;
   
   input [2-1:0]           M0_slave;
   
   output [1-1:0]           S0_master;
   output [1-1:0]           S1_master;
   output [1-1:0]           S2_master;


   
   reg [1:0]               S0_master_prio_reg;
   reg [1:0]               S1_master_prio_reg;
   reg [1:0]               S2_master_prio_reg;
   wire [1-1:0]               S0_master_prio;
   wire [1-1:0]               S1_master_prio;
   wire [1-1:0]               S2_master_prio;
   reg [1-1:0]               S0_master_d;
   reg [1-1:0]               S1_master_d;
   reg [1-1:0]               S2_master_d;
   
   wire [1-1:0]               M_S0;
   wire [1-1:0]               M_S1;
   wire [1-1:0]               M_S2;
   wire [1-1:0]               M_S0_valid;
   wire [1-1:0]               M_S1_valid;
   wire [1-1:0]               M_S2_valid;
   wire [1-1:0]               M_S0_prio;
   wire [1-1:0]               M_S1_prio;
   wire [1-1:0]               M_S2_prio;
   reg [1-1:0]               M_S0_burst;
   reg [1-1:0]               M_S1_burst;
   reg [1-1:0]               M_S2_burst;


   
   
   parameter                   MASTER_NONE = 1'b0;
   parameter                   MASTER0    = 1'b1;
   
   
   

   always @(posedge clk or posedge reset)
     if (reset)
       begin
      S0_master_prio_reg[1:1] <= #1 {1{1'b0}};
      S1_master_prio_reg[1:1] <= #1 {1{1'b0}};
      S2_master_prio_reg[1:1] <= #1 {1{1'b0}};
      S0_master_prio_reg[0]          <= #1 1'b1;
      S1_master_prio_reg[0]          <= #1 1'b1;
      S2_master_prio_reg[0]          <= #1 1'b1;
       end
     else if (|(M_req & M_grant & M_last))
       begin      
      S0_master_prio_reg[1:1] <= #1 S0_master_prio_reg[1-1:0];
      S1_master_prio_reg[1:1] <= #1 S1_master_prio_reg[1-1:0];
      S2_master_prio_reg[1:1] <= #1 S2_master_prio_reg[1-1:0];
      S0_master_prio_reg[0]          <= #1 S0_master_prio_reg[1-1];
      S1_master_prio_reg[0]          <= #1 S1_master_prio_reg[1-1];
      S2_master_prio_reg[0]          <= #1 S2_master_prio_reg[1-1];
       end

   assign S0_master_prio = S0_master_prio_reg[1-1:0];
   assign S1_master_prio = S1_master_prio_reg[1-1:0];
   assign S2_master_prio = S2_master_prio_reg[1-1:0];
   
   assign M_S0_prio      = M_S0_valid & S0_master_prio;
   assign M_S1_prio      = M_S1_valid & S1_master_prio;
   assign M_S2_prio      = M_S2_valid & S2_master_prio;
   


   always @(posedge clk or posedge reset)
     if (reset)
       begin
      S0_master_d <= #1 {1{1'b0}};
      S1_master_d <= #1 {1{1'b0}};
      S2_master_d <= #1 {1{1'b0}};
       end
     else
       begin
      S0_master_d <= #1 S0_master;
      S1_master_d <= #1 S1_master;
      S2_master_d <= #1 S2_master;
       end

     always @(posedge clk or posedge reset)                        
       if (reset)                                                  
     begin                                                     
        M_S0_burst[0] <= #1 1'b0;                        
        M_S1_burst[0] <= #1 1'b0;                        
        M_S2_burst[0] <= #1 1'b0;                        
     end                                                       
       else if (M_req[0])                         
     begin                                                     
        M_S0_burst[0] <= #1 S0_master[0] & (M_grant[0] ? (~M_last[0]) : 1'b1); 
        M_S1_burst[0] <= #1 S1_master[0] & (M_grant[0] ? (~M_last[0]) : 1'b1); 
        M_S2_burst[0] <= #1 S2_master[0] & (M_grant[0] ? (~M_last[0]) : 1'b1); 
     end
   
      
     assign                              M_S0 = {M0_slave == 'd0 };
     assign                              M_S1 = {M0_slave == 'd1 };
     assign                              M_S2 = {M0_slave == 'd2 };
   
   assign                  M_S0_valid = M_S0 & M_req;
   assign                  M_S1_valid = M_S1 & M_req;
   assign                  M_S2_valid = M_S2 & M_req;
   
   
     assign                    S0_master = 
                               M_S0_burst[0] ? S0_master_d : 
                                           M_S0_prio[0]  ? MASTER0 :  
                            M_S0_valid[0] ? MASTER0 :      
                            MASTER_NONE;
   
     assign                    S1_master = 
                               M_S1_burst[0] ? S1_master_d : 
                                           M_S1_prio[0]  ? MASTER0 :  
                            M_S1_valid[0] ? MASTER0 :      
                            MASTER_NONE;
   
     assign                    S2_master = 
                               M_S2_burst[0] ? S2_master_d : 
                                           M_S2_prio[0]  ? MASTER0 :  
                            M_S2_valid[0] ? MASTER0 :      
                            MASTER_NONE;
   
      
     endmodule



